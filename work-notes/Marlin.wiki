[[index|Hame Page]]

%toc index

== To-Do list: ==

    @ How to build code into Library. (.a or .so) [ok]<br>
    @ What is mp4 format. [ok]<br>
    @ How to process Marlin File Formats (understand the Specification). [ok]<br>
    @ Know about PE APIs.i [ok]<br>
    @ Understand the ffmpeg demuxers and create a demuxer for marlin. [ok]<br>
    @ How to parse. [ok]<br>

== 1. HMMP (HyperMedia Management Protocol) ==
Already WBEM has developed three Web-based standards:
    * HyperMedia Management Protocol (HMMP) allows browsers to access and receive systems and network management data, such as alerts and event reports, from devices and applications.
    * HyperMedia Management Schema (HMMS), or Common Information Model (CIM), provides a common way to describe and share management information across the enterprise.
    * HyperMedia Object Manager (HMOM) gathers management data from applications to be displayed on consoles.

--------------------------------------------------

== 2. DRM (Digital Rights Management) ==
related link:<br>
	http://en.wikipedia.org/wiki/Digital_rights_management
	
--------------------------------------------------

== 3. PE (see "~/workspace/marvell/88DE3010 Software API User Manual.pdf") ==
	PE (Presentation Engine) manages the playing back of the media streams. PE 
provides the following services:<br>
	* Audio codec and post processing
	* Video decoder and post processing
	* GFX engine
	* Demux engine
	* Security engine
--------------------------------------------------

== 4. GStreamer(see "http://en.wikipedia.org/wiki/GStreamer") ==
	A pipeline-based multimedia framework written in the C programming language 
with the type system based on GObject.

--------------------------------------------------

== 5. FFMPEG (see "http://www.ffmpeg.org/") ==
	FFmpeg(Fast Foward MPEG) is a complete, cross-platform solution to record, convert and stream 
audio and video. It includes libavcodec - the leading audio/video codec library.

--------------------------------------------------

== 6. JNI (Java Native Interface) ==
	A programming framework that enables Java code running in a Java Virtual 
Machine (JVM) to call and to be called[1] by native applications (programs 
specific to a hardware and operating system platform) and libraries written in 
other languages, such as C, C++ and assembly.

--------------------------------------------------

== 7. SOLS Playback Steps ==
(refer to "~/workspace/marvell/marlin/SOLS_Marlin_Arch_4_Marvell.pdf")<br>
	* Register the device to a DRM domain
	* User navigates and selects a video
	* Video guide passes content URL, CAD URL, and tokens(for example, user, 
	  service, and affiliation)
	* SOLS player uses content URL to stream the video from content server
	* SOLS player parses MP4/IPMP content to extract DRM data
	* SOLS player uses CAD URL to download a CAD file, which contains license 
	  acquisition URL and information about what data are required for 
	  retrieving a license
	* Marlin client uses device information and DRM data from content file to 
	  generate a challenge
	* Marlin client posts the challenge and other required data to request the 
	  license
	* Marlin client decrypts the license to get content key and usage rules
	* Marlin client checks usage rules
	* Marlin client decrypts content samples
	* SOLS player decodes content samples

--------------------------------------------------
	
== 8. MPEG-4 (see "http://en.wikipedia.org/wiki/MPEG-4") ==
	MPEG-4 is method of defining compression of audio and visual (AV) digital 
data. It was introduced in late 1998 and designated a standard for a group of 
audio and video coding formats and related technology agreed upon by the 
ISO/IEC Moving Picture Experts Group (MPEG) (ISO/IEC JTC1/SC29/WG11) under the 
formal standard ISO/IEC 14496 - Coding of audio-visual objects. Uses of MPEG-4 
include compression of AV data for web (streaming media) and CD distribution, 
voice (telephone, videophone) and broadcast television applications.

--------------------------------------------------

== 9. Marlin (See "http://www.marlin-community.com/") ==
	The content sharing platform for consumer devices and multimedia services.
	Five companies — Intertrust, Panasonic, Philips, Samsung and Sony - joined 
together in 2005 to develop specifications for next-generation content and 
rights management technology.

--------------------------------------------------

== 10. MPEG-4 Part 14 ==
	See http://en.wikipedia.org/wiki/MPEG-4_Part_14.<br>

--------------------------------------------------

== 11. Some terminology ==
	*BIFS*: Binary Format for Scenes (BIFS) is a binary format for two- or three-dimensional audiovisual content. It is based on VRML and part 11 of the MPEG-4 standard.<br>
	*OD*: Object Descriptor.<br>
	MIME type: Multipurpose Internet Mail Extensions, refer to http://zh.wikipedia.org/wiki/MIME<br>
	*UUID*: A Universally Unique Identifier<br>
	*IPMP*: Intellectual Property Management and Protection<br>
	*RTP*: Real-time Transport Protocol, refer to http://en.wikipedia.org/wiki/Network_packet<br>
	*SDP*: Session Description Protocol, a format for describing streaming media initialization parameters. refer to http://en.wikipedia.org/wiki/Session_Description_Protocol<br>
	*NAL* units: Network Abstraction Layer units. H.264 describes a number of NAL units, a sequence of which can be decoded into video frames. These NAL units have no boundary markers, and rely on some unspecified format to provide framing, refer to http://wiki.multimedia.cx/index.php?title=H.264<br>
	*NEMO*: <br>
	
    More terms see "MarlinArchitectureOverview.pdf".<br>

--------------------------------------------------

== 12. Building steps ==
	In "/MV88DE3015_SDK/Software_C3_PEK_56_60_140_ReleaseInfo_Linux_BG2_BDP":<br>
	1) Set environment.<br>
	Something wrong with rootfs, we need to edit "~/.bashrc" to add a variable as:
    export GALOIS_LINUX_ROOT=~/workspace/marvell/marlin/SDK_release_package/MV88DE3015_SDK/Customization_Data/File_Systems/rootfs
	2) make Berlin_Player_Single_CPU_BG2<br>
		a. Force copy libsupc++.a and libstdc++.a to "SDK_release_package/MV88DE3015_SDK/Customization_Data/File_Systems/rootfs/usr/lib". Then try to make again. Finally, use bg1 toolchain for building.<br>
		b. After U-Boot being brought up, use "setenv"
    setenv bootargs 'macaddr=00:80:11:11:00:41 console=ttyS0,115200 root=/dev/nfs nfsroot=192.168.1.145:/home/yliao/workspace/marvell/marlin/SDK_release_package/MV88DE3015_SDK/Customization_Data/File_Systems/rootfs,v3 ip=dhcp'<br>

	NOTE! The SDK is bad - -! Rebuild it in our Android.<br>
	1) Use svn update trunk in "/home/yliao/workspace/marvell/mrvl/trunk".<br>
    $ cd PATH_TO_TRUNK<br>
    $ svn up --force<br>
	2) Run scripts.<br>
    $ ./froyo-nand-dma.sh bg2<br>
    $ ./froyo-copy-android-rootfs.sh bg2<br>
	NOTE: toolchains use<br>
    ../mrvl/trunk/MV88DE3015_SDK/SDK_Tools/cross_toolchain/tarballs<br>

--------------------------------------------------

== 13. Add busybox for android. ==
	1) Config, in busybox source tree, modify Makefile.<br>
    CROSSCOMPILE = arm-marvell-linux-gnueabi-<br>
	then<br>
    $ make menuconfig<br>
    Busybox Settings -> Build Options -><br>
    [*] Build BusyBox as a static binary (no shared libs)<br>
    Busybox Settings -> Installation Options-><br>
    [*] Don’t use /usr<br>
	Save.<br>
	2) Build.<br>
    $ make<br>
    $ make install<br>
	3) In Android console(serial port)<br>
    $# cd /data/<br>
    $# mkdir busybox<br>
	Then copy "BB_SRC_TREE/busybox" and "BB_SRC_TREE/_install/bin" into that newly created folder. and, <br>
    $# cd /data/busybox<br>
    $# chmod 777 busybox<br>
	4) Modify environment PATH in "mrvl/trunk/MV88DE3015_SDK/Customization_Data/File_Systems/system/init.rc".<br>
    export PATH /data/busybox/bin:/sbin:/system/sbin:/system/bin:/system/xbin:/BDP/bin<br>
	NOTE: If cannot use busybox command tab completion when first boot into Android console, <br>
	run command below after each bootup:<br>
    $# sh<br>

--------------------------------------------------

== 14. Post Build Android ==
	Modify init.rc:
    export PATH /data/busybox/bin:/sbin:/system/sbin:/system/bin:/system/xbin:/BDP/bin:/data/app/bin<br>
    export LD_LIBRARY_PATH /system/lib:/BDP/lib:/data/app/lib<br>

	NOTE! The normal built application cannot run in Android env, <br>
	it should be built along with Android as below steps:<br>
	1) in ~/.bashrc:<br>
    export GALOIS_LINUX_ROOT=$SDK_Release/MV88DE3015_SDK/Customization_Data/File_Systems/rootfs<br>
	2) in Android Tree, "$(ANDROID_TREE)/Android_SDK/":<br>
    $ . build/envsetup.sh<br>
    $ chooseproduct berlin_bg2<br>
	Then, type:<br>
    $ help<br>
	and we can see information below:<br>
    Invoke ". build/envsetup.sh" from your shell to add the following functions to your environment:<br>
    -- croot:   Changes directory to the top of the tree.<br>
    -- m:       Makes from the top of the tree.<br>
    -- mm:      Builds all of the modules in the current directory.<br>
    -- mmm:     Builds all of the modules in the supplied directories.<br>
    -- cgrep:   Greps on all local C/C++ files.<br>
    -- jgrep:   Greps on all local Java files.<br>
    -- resgrep: Greps on all local res/*.xml files.<br>
    -- godir:   Go to the directory containing a file.<br>
    -- <br>
    -- Look at the source to view more functions. The complete list is:<br>
    -- add_lunch_combo cgrep check_product check_variant choosecombo chooseproduct choosetype choosevariant cproj croot findmakefile gdbclient get_abs_build_var getbugreports get_build_var getprebuilt gettop godir help isviewserverstarted jgrep lunch m mm mmm pid printconfig print_lunch_menu resgrep runhat runtest setpaths set_sequence_number set_stuff_for_environment settitle smoketest startviewserver stopviewserver systemstack tapas tracedmdump<br>
	3) Build use comand "m", "mm" or "mmm".
--------------------------------------------------

== 15. Some paths. ==
    "solsmp library" source is put in "$(ANDROID_TREE)/external/solsmp"<br>
	which can refer to "gst-plugins-mrvl"<br>
    "solsmp_test application" source is put in "$(ANDROID_TREE)/vendor/marvell/generic/solsmp_test"<br>
	which can refer to "mrvl_media_player"<br>

--------------------------------------------------

== 16. URI & URL ==
	short for: Uniform Resource Identifier<br>
	In computing, a Uniform Resource Identifier (URI) is a string of characters used to identify a name or a resource on the Internet.<br>
	A downloadable media object is located on the Web using a uniform resource locator (URL) and identified using a universal resource identifier (URI). A URI is a member of the universal set of names in registered name spaces and addresses referring to registered protocols or name spaces. A URL is a form of URI that expresses an address that maps onto an access algorithm using network protocols. The uniform resource name (URN) debate attempts to define a name space (and presumably resolution protocols) for persistent object names.<br>

--------------------------------------------------

== 17. Write C application and build into Android system ==
Refer to:<br>
    $(CURRENT_PATH)/materials/Android_SDK<br>
    file:///home/yliao/vimwiki/materials/Android_SDK<br>

NOTE!<br>
The local includes should be written as:<br>
{{{
LOCAL_C_INCLUDES := \
    $(LOCAL_PATH)   \
    $(LOCAL_PATH)/rmvb_DR  \
    external/ffmpeg/libavcodec \
    external/ffmpeg/libavformat \
    external/ffmpeg/libavutil \
    external/ffmpeg/ \
    external/glib                   \
    external/glib/android           \
    external/glib/glib
}}}
The local source files should be written as:<br>
{{{
LOCAL_SRC_FILES:= \
    AVFilePlayer.c \
	ExternalSubtitle.c \
	AVFileParser.c \
	AVFileUtils.c \
	DivXPlayer.c \
	Packet_Queue.c \
	RawPcmDR.c \
	ffmpeg_dr.c \
	rmvb_DR/helix_date.c  \
	rmvb_DR/ra_depack_internal.c \
	rmvb_DR/rm_io_default.c \
	rmvb_DR/rm_parser_internal.c \
	rmvb_DR/rv_depack_internal.c \
	rmvb_DR/memory_utils.c \
	rmvb_DR/rasl.c \
	rmvb_DR/rm_memory_default.c \
	rmvb_DR/rm_property.c \
	rmvb_DR/stream_hdr_utils.c \
	rmvb_DR/pack_utils.c \
	rmvb_DR/rmdemux.c \
	rmvb_DR/rm_packet.c \
	rmvb_DR/rm_stream.c \
	rmvb_DR/string_utils.c \
	rmvb_DR/ra_depack.c \
	rmvb_DR/rm_error_default.c \
	rmvb_DR/rm_parser.c \
	rmvb_DR/rv_depack.c \
	getxattr.S
}}}
Detailed info refer to:<br>
    http://hashspeaks.wordpress.com/2010/01/27/android-mk-documentation/<br>

--------------------------------------------------

== 18. mp4 file format	 ==
Refer to this page:<br>
    http://blog.sina.com.cn/s/blog_48f93b530100jz4b.html<br>
A typical mp4 file format:<br>
	[[res/img/mp4ff.jpg||width:127px;height:199px;]]<br>
Such as: [[/home/yliao/vimwiki/materials/6.mp4]]<br>
	[[res/img/6_mp4_structure.png||width:240px;height:555px;]]<br>
A mp4 file format map:<br>
	[[res/img/mp4ffmap.jpg||width:446px;height:690px;]]<br>

--------------------------------------------------

== 19. Byte Order ==

Big Endian(mp4 file):<br>
    MSB -- Low addr.<br>
    LSB -- High addr.<br>
Little Endian:<br>
    MSB -- High addr.<br>
    LSB -- Low addr.<br>
network byte order:<br>
    same as Big Endian<br>

== 20. mrvl_media_player ==

application flow:<br>
    main.cpp<br>
        |<br>
    MRVLMediaPlayer.cpp (choose Player)<br>
        |<br>
    MRVLFFPlayer.cpp (call wrapper)<br>
        |<br>
    AVFileUtils.c (wrapper)<br>
        |<br>
    AVFilePlayer.c (call FFMPEG_CreateDR(), DR_Probe() and so on)<br>
        |<br>
    ffmpeg_dr.c (FFmpeg data retriever)<br>
        |<br>
    FFmpeg library<br>

e.g. DR_Probe shown as image below:<br>
	[[res/img/CalledByGraph-av_open_input_file.png]]<br>
	note: "av_open_input_file" is the interface between player and ffmpeg.<br>
{{{
/**
 * Opens a media file as input. The codecs are not opened. Only the file
 * header (if present) is read.
 *
 * @param ic_ptr The opened media file handle is put here.
 * @param filename filename to open
 * @param fmt If non-NULL, force the file format to use.
 * @param buf_size optional buffer size (zero if default is OK)
 * @param ap Additional parameters needed when opening the file
 *           (NULL if default).
 * @return 0 if OK, AVERROR_xxx otherwise
 */
int av_open_input_file(AVFormatContext **ic_ptr, const char *filename,
                       AVInputFormat *fmt,
                       int buf_size,
                       AVFormatParameters *ap);
}}}

== 21. ffmpeg demux ==
AVInputFormat is a link list, declared as:<br>
{{{
typedef struct AVInputFormat {
    const char *name;
    /**
     * Descriptive name for the format, meant to be more human-readable
     * than name. You should use the NULL_IF_CONFIG_SMALL() macro
     * to define it.
     */
    const char *long_name;
    /** Size of private data so that it can be allocated in the wrapper. */
    int priv_data_size;
    /**
     * Tell if a given file has a chance of being parsed as this format.
     * The buffer provided is guaranteed to be AVPROBE_PADDING_SIZE bytes
     * big so you do not have to check for that unless you need more.
     */
    int (*read_probe)(AVProbeData *);
    /** Read the format header and initialize the AVFormatContext
       structure. Return 0 if OK. 'ap' if non-NULL contains
       additional parameters. Only used in raw format right
       now. 'av_new_stream' should be called to create new streams.  */
    int (*read_header)(struct AVFormatContext *,
                       AVFormatParameters *ap);
    /** Read one packet and put it in 'pkt'. pts and flags are also
       set. 'av_new_stream' can be called only if the flag
       AVFMTCTX_NOHEADER is used.
       @return 0 on success, < 0 on error.
               When returning an error, pkt must not have been allocated
               or must be freed before returning */
    int (*read_packet)(struct AVFormatContext *, AVPacket *pkt);
    /** Close the stream. The AVFormatContext and AVStreams are not
       freed by this function */
    int (*read_close)(struct AVFormatContext *);

#if LIBAVFORMAT_VERSION_MAJOR < 53
    /**
     * Seek to a given timestamp relative to the frames in
     * stream component stream_index.
     * @param stream_index Must not be -1.
     * @param flags Selects which direction should be preferred if no exact
     *              match is available.
     * @return >= 0 on success (but not necessarily the new offset)
     */
    int (*read_seek)(struct AVFormatContext *,
                     int stream_index, int64_t timestamp, int flags);
#endif
    /**
     * Gets the next timestamp in stream[stream_index].time_base units.
     * @return the timestamp or AV_NOPTS_VALUE if an error occurred
     */
    int64_t (*read_timestamp)(struct AVFormatContext *s, int stream_index,
                              int64_t *pos, int64_t pos_limit);
    /** Can use flags: AVFMT_NOFILE, AVFMT_NEEDNUMBER. */
    int flags;
    /** If extensions are defined, then no probe is done. You should
       usually not use extension format guessing because it is not
       reliable enough */
    const char *extensions;
    /** General purpose read-only value that the format can use. */
    int value;

    /** Starts/resumes playing - only meaningful if using a network-based format
       (RTSP). */
    int (*read_play)(struct AVFormatContext *);

    /** Pauses playing - only meaningful if using a network-based format
       (RTSP). */
    int (*read_pause)(struct AVFormatContext *);

    const struct AVCodecTag * const *codec_tag;

    /**
     * Seeks to timestamp ts.
     * Seeking will be done so that the point from which all active streams
     * can be presented successfully will be closest to ts and within min/max_ts.
     * Active streams are all streams that have AVStream.discard < AVDISCARD_ALL.
     */
    int (*read_seek2)(struct AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags);

    const AVMetadataConv *metadata_conv;

    /* private fields */
    struct AVInputFormat *next;
} AVInputFormat;
}}}

ffmpeg refer to<br>
    http://blog.csdn.net/wstarx/archive/2007/04/20/1572393.aspx<br>

To add a demuxer named "marlin.c", we need do such steps:<br>
# Prepare marlin.c
# In Android.mk, add source file
# In config.h, add #define CONFIG_MARLIN_DEMUXER 1
# In allformats.c, add REGISTER_DEMUXER  (MARLIN, marlin);

read_probe called by:<br>
[[res/img/CalledByGraph-read_probe.png]]<br>

read_header called by:<br>
[[res/img/CalledByGraph-read_header.png]]<br>

ffmpeg demux control flow:<br>

MV_AVFilePlayer_play<br>
|<br>
FFMPEG_DR_Probe<br>
|<br>
av_open_input_files -> av_open_input_stream (see below)<br>
|<br>
av_probe_input_format<br>
|<br>
score = read_probe (for(;;))<br>
|<br>
(xxx_probe)<br>
<br>
av_open_input_stream<br>
|<br>
read_header<br>
|<br>
xxx_read_header (xxx_demuxer)<br>
|<br>
get_be/get_le, parse (while())<br>
|<br>
read_xxx (parse_table)<br>
<br>

Steps of add a header to read (e.g.):<br>
in marlin_default_parse_table[],<br>
add a line `{ MKTAG('f','r','e','e'), marlin_read_free },`<br>
then add a function `static int marlin_read_free(MOVContext *c, ByteIOContext *pb, MOVAtom atom)`<br>
all ok.<br>

NOTE! to read buffer, <br>
use `get_buffer(ByteIOContext *s, unsigned char *buf, int size)` to store data in a string *buf.<br>
and `get_beXX`/`get_leXX` can only return a numeric value.<br>

== 22. Octopus ==
	The rights management within Marlin is based on a general-purpose DRM architecture (Octopus) that is extremely expressive and allows for flexible business rules. At the center of an Octopus system is a graph-based relationship engine. In Marlin, Octopus node objects are used to represent system entities (such as users and devices), and links between nodes represent relationships. The system of nodes and links is integral to managing where, how, and when content can be used in a Marlin system. Octopus is designed to run on various platforms, from smartcards to servers, being media format and cryptographically agnostic. It is extensible for future-proofing systems, easily configurable, optimized for small systems, and semantics-free.<br> (refer to http://en.wikipedia.org/wiki/Marlin_%28DRM%29)
	*The ability to separate the protection of content from the governance of that content.*

== 23. some make errors ==
1) about clean_steps.mk, like below:<br>
{{{
yliao@banana-l-d:~/work/marvell/mrvl/trunk/Android_SDK/vendor/marvell/generic/solsmp$ mm
============================================
PLATFORM_VERSION_CODENAME=REL
PLATFORM_VERSION=2.2
TARGET_PRODUCT=berlin_bg2
TARGET_BUILD_VARIANT=eng
TARGET_SIMULATOR=
TARGET_BUILD_TYPE=release
TARGET_BUILD_APPS=
TARGET_ARCH=arm
HOST_ARCH=x86
HOST_OS=linux
HOST_BUILD_TYPE=release
BUILD_ID=MASTER
============================================
make: Entering directory `/home/yliao/work/marvell/mrvl/trunk/Android_SDK'
out/target/product/berlin_bg2/clean_steps.mk:3: *** missing separator.  Stop.
make: Leaving directory `/home/yliao/work/marvell/mrvl/trunk/Android_SDK'
yliao@banana-l-d:~/work/marvell/mrvl/trunk/Android_SDK/vendor/marvell/generic/solsmp$
}}}
solution: It works fine by deleting that file. (it will be generated automatically while building android)<br>

== 24. back into demux packet ==
See read_frame()<br>
	[[res/img/CalledByGraph-av_read_frame.png]]<br>
	[[res/img/CallsGraph-av_read_frame.png]]<br>
	
== 25. Build SOLSPlayer at Marvell ==
	1. ssh ies@10.38.120.51<br>
	   password: 123456<br>
	2. make a copy of Marlin_42574_0705 as Marlin_42574_0705_yliao<br>
	3. source marlin_build_env.sh<br>
	4. cd Marlin_42574_0705_yliao<br>
	   make Berlin_SOLSPlayer<br>
	5. tar and copy "Builds" dir to local PC:<br>
	   ~/workspace/marvell/marlin/home/berlin/berlin_rootfs/home/yliao<br>
	6. then cp some scripts to dir above<br>
	7. U-Boot env:<br>
{{{
	setenv bootargs 'macaddr=00:50:F3:01:1F:A1 root=/dev/nfs console=ttyS0,115200 nfsroot=10.38.54.187:/home/yliao/workspace/marvell/marlin/marlin_rootfs_ies/home/berlin/berlin_rootfs,v3 ip=dhcp init=/init androidboot.console=ttyS0'
	setenv bootfile 'ies/yliao/uImage'
}}}

%template header-footer
